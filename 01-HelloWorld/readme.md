## Code:
```
section .data
    message db 'Hello, World!',0

section .text
    global _start

_start:
    ; Print the message
    mov eax, 4           ; System call number for write
    mov ebx, 1           ; File descriptor (stdout)
    mov ecx, message     ; Address of the message string
    mov edx, 13          ; Length of the message
    int 0x80             ; Call the kernel

exit:
    mov eax, 1           ; System call number for exit
    xor ebx, ebx         ; Exit code (0)
    int 0x80             ; Call the kernel
```
- We use [**eax** register](https://github.com/GrimIrani/EasyAssemblyx64/tree/main/01-HelloWorld#register) to store the system call number (like requesting a specific operation from the operating system).
- We use [**ebx** register](https://github.com/GrimIrani/EasyAssemblyx64/tree/main/01-HelloWorld#register) to store information like file descriptors or addresses.
- We use [**ecx** register](https://github.com/GrimIrani/EasyAssemblyx64/tree/main/01-HelloWorld#register) to hold strings or memory addresses.
- We use [**edx** register](https://github.com/GrimIrani/EasyAssemblyx64/tree/main/01-HelloWorld#register) to hold lengths or sizes of data being manipulated.
## Compile:
you can use [NASM (Netwide Assembler)](https://github.com/GrimIrani/EasyAssemblyx64/tree/main/01-HelloWorld#assemble) to [assemble](https://github.com/GrimIrani/EasyAssemblyx64/tree/main/01-HelloWorld#assemble) the code and [ld (GNU Linker)](https://github.com/GrimIrani/EasyAssemblyx64/tree/main/01-HelloWorld#ld-and-link) to link it. Here's how you can do it:
```
nasm -f elf64 main.asm     // Assemble the code

ld -o helloworld main.o    // Link the assembled object file
```
# HomeWork:
Change the code to print "0123456789abcdef" </br>
Any problem? see `Homeworked.md`
## Q/A
#### register:
Q: What's a **register**? </br>
A: Registers are like tiny storage spaces inside the computer's processor. They can store and hold data temporarily. Think of them as small containers that can hold values or pieces of information that the processor needs to keep track of while performing calculations or executing instructions.
#### ld and link:
Q: What is **ld and linking**? </br>
A: 'ld' is the GNU Linker, a program that takes object files generated by an assembler (like NASM) and combines them together to create an executable file. It resolves references between different parts of the code, making sure that all the necessary functions and data are available.
#### assemble:
Q: What's **NASM**? <br/>
A: NASM stands for Netwide Assembler. It is an assembler program used to assemble assembly language code into machine code that can be executed by the computer's processor. NASM supports multiple output formats, including Windows PE and Linux ELF.

Q: What's an **assembler**? </br>
A: An assembler is a program that translates assembly language code into machine code, which consists of instructions that can be directly executed by the computer's processor.

Q: What does **"format"** refer to in **"nasm -f elf64"**? </br>
A: In the context of NASM, the format option specifies the output file format for the assembled code. The elf64 format refers to the Executable and Linkable Format (ELF) for x86-64 architecture. It is commonly used on Unix-like operating systems, including Linux.

#### More questions:
Q: So I code in assembly, but it's not machine code? <br/>
A: Any assembly language is for humans <br/>
and the only language the system know is the machine code <br/>
you write assembly and the assembler translate it to machine code.

Q: Why we need assembler? why can't assembly run itself, I mean it's low level. </br>
A: The assembler do not more then a translate its like this:
| Assembly | opcode |
| -------- | ------ |
| null | null |

you can use a HEX editor to see the executable file exacly made from translating assembly to this opcodes.

